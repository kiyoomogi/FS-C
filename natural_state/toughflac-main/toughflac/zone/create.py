from __future__ import division

import numpy

try:
    import itasca as it
    from itasca import gridpointarray as gpa
except ImportError:
    pass


__all__ = [
    "tartan_brick",
]


def tartan_brick(dx, dy, dz, point_0=[0.0, 0.0, 0.0], group=None):
    """
    Create a 3D irregular cartesian grid.

    Parameters
    ----------
    dx : array_like
        Step (in meters) in X direction.
    dy : array_like
        Step (in meters) in Y direction.
    dz : array_like
        Step (in meters) in Z direction.
    point_0 : list, optional, default [0., 0., 0.]
        Origin point coordinate.
    group : str or None, optional, default None
        Grid zone group name.

    Note
    ----
    This function creates a regular brick by calling FLAC3D :command:`zone create brick size nx ny nz` where ``nx``, ``ny`` and ``nz`` are the size of `dx`, `dy` and `dz`. Correct gridpoint positions are then calculated using :mod:`numpy` and then modified using :func:`itasca.gridpointarray.set_pos`.

    """
    if not isinstance(dx, (list, tuple, numpy.ndarray)):
        raise TypeError("dx must be a list, tuple or ndarray.")
    if not isinstance(dy, (list, tuple, numpy.ndarray)):
        raise TypeError("dy must be a list, tuple or ndarray.")
    if not isinstance(dz, (list, tuple, numpy.ndarray)):
        raise TypeError("dz must be a list, tuple or ndarray.")
    if numpy.any(numpy.asarray(dx) <= 0.0):
        raise ValueError("All elements in dx must be positive.")
    if numpy.any(numpy.asarray(dy) <= 0.0):
        raise ValueError("All elements in dy must be positive.")
    if numpy.any(numpy.asarray(dz) <= 0.0):
        raise ValueError("All elements in dz must be positive.")
    if not isinstance(point_0, (list, tuple, numpy.ndarray)):
        raise TypeError("point_0 must be a list, tuple or ndarray.")
    if len(point_0) != 3:
        raise ValueError("point_0 must have 3 coordinates.")
    if not (group is None or isinstance(group, str)):
        raise TypeError("group must be a string.")

    # Internal functions
    def meshgrid(x, y, z, indexing="ij", order="F"):
        X, Y, Z = numpy.meshgrid(x, y, z, indexing=indexing)
        return X.ravel(order), Y.ravel(order), Z.ravel(order)

    def mesh_vertices(i, j, k):
        return [
            [i, j, k],
            [i + 1, j, k],
            [i, j + 1, k],
            [i, j, k + 1],
            [i + 1, j + 1, k],
            [i, j + 1, k + 1],
            [i + 1, j, k + 1],
            [i + 1, j + 1, k + 1],
        ]

    # Grid
    nx, ny, nz = len(dx), len(dy), len(dz)
    xyz_shape = [nx + 1, ny + 1, nz + 1]
    ijk_shape = [nx, ny, nz]
    X, Y, Z = meshgrid(*[numpy.cumsum(numpy.r_[0, ar]) for ar in [dx, dy, dz]])
    I, J, K = meshgrid(*[numpy.arange(n) for n in ijk_shape])

    # Points and cells
    points = [[x, y, z] for x, y, z in zip(X, Y, Z)]
    cells = [
        [
            numpy.ravel_multi_index(vertex, xyz_shape, order="F")
            for vertex in mesh_vertices(i, j, k)
        ]
        for i, j, k in zip(I, J, K)
    ]

    # Generate regular brick using internal command
    cmd = "zone create brick size {} {} {}".format(nx, ny, nz)
    if group:
        cmd += " group '{}'".format(group)
    it.command(cmd)

    # Update gridpoint positions in the order they were generated by FLAC3D
    gridpoints, s = [], set()
    for cell in cells:
        gridpoints.extend([points[v] for v in cell if v not in s])
        s.update(cell)
    gridpoints = numpy.array(gridpoints) + numpy.asarray(point_0)
    gpa.set_pos(gridpoints)
